<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lyria RealTime Music Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 400px;
            text-align: center;
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #status {
            margin-top: 10px;
            font-style: italic;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Lyria RealTime Music Generator</h2>
        <p>Enter your prompt (e.g., "upbeat electronic dance"):</p>
        <input type="text" id="prompt" placeholder="Describe the music style">
        <button id="start">Start Music</button>
        <button id="stop">Stop</button>
        <button id="download">Download as WAV</button>
        <div id="status">Status: Ready</div>
    </div>

    <script>
        const API_KEY = 'YOUR_API_KEY_HERE';  // Replace with your API key from aistudio.google.com
        const MODEL = 'models/lyria-realtime-exp';

        let ws;
        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioQueue = [];
        let isPlaying = false;
        let fullAudioData = [];  // To collect all chunks for download

        async function playChunk(buffer) {
            const audioBuffer = await audioContext.decodeAudioData(buffer);
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            source.start();
        }

        function playNext() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                return;
            }
            isPlaying = true;
            const buffer = audioQueue.shift();
            playChunk(buffer).then(() => playNext());
        }

        function connect(prompt) {
            if (!prompt) {
                alert('Please enter a prompt!');
                return;
            }
            fullAudioData = [];  // Reset for new session
            ws = new WebSocket(`wss://generativelanguage.googleapis.com/v1alpha/${MODEL}:streamGenerate?key=${API_KEY}`);

            ws.onopen = () => {
                document.getElementById('status').textContent = 'Status: Connected - Generating music...';
                // Send initial setup (optional: bpm, etc.)
                ws.send(JSON.stringify({
                    setup: {
                        bpm: 120,  // Example BPM
                        temperature: 0.8  // Creativity level
                    }
                }));
                // Send prompt
                ws.send(JSON.stringify({
                    prompts: [{ text: prompt, weight: 1.0 }]
                }));
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.audioChunks) {
                    data.audioChunks.forEach(chunk => {
                        const binary = atob(chunk.data);  // Base64 to binary
                        const array = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) {
                            array[i] = binary.charCodeAt(i);
                        }
                        const buffer = array.buffer;
                        audioQueue.push(buffer);
                        fullAudioData.push(array);  // Collect for download
                        if (!isPlaying) playNext();
                    });
                }
            };

            ws.onclose = () => {
                document.getElementById('status').textContent = 'Status: Disconnected';
            };

            ws.onerror = (error) => {
                document.getElementById('status').textContent = 'Status: Error - Check API key or connection';
                console.error(error);
            };
        }

        document.getElementById('start').onclick = () => {
            const prompt = document.getElementById('prompt').value;
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                connect(prompt);
            }
        };

        document.getElementById('stop').onclick = () => {
            if (ws) ws.close();
            audioQueue = [];
            isPlaying = false;
            document.getElementById('status').textContent = 'Status: Stopped';
        };

        document.getElementById('download').onclick = () => {
            if (fullAudioData.length === 0) {
                alert('No audio generated yet!');
                return;
            }
            // Combine all chunks into one Uint8Array
            const totalLength = fullAudioData.reduce((acc, arr) => acc + arr.length, 0);
            const combined = new Uint8Array(totalLength);
            let offset = 0;
            fullAudioData.forEach(arr => {
                combined.set(arr, offset);
                offset += arr.length;
            });

            // Create WAV header (assuming PCM 16-bit, 48kHz stereo)
            const sampleRate = 48000;
            const numChannels = 2;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = combined.length;
            const header = new ArrayBuffer(44);
            const view = new DataView(header);

            // RIFF header
            view.setUint32(0, 0x52494646, false);  // 'RIFF'
            view.setUint32(4, 36 + dataSize, true);
            view.setUint32(8, 0x57415645, false);  // 'WAVE'

            // fmt chunk
            view.setUint32(12, 0x666d7420, false);  // 'fmt '
            view.setUint32(16, 16, true);  // Subchunk1Size
            view.setUint16(20, 1, true);  // AudioFormat (PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);

            // data chunk
            view.setUint32(36, 0x64617461, false);  // 'data'
            view.setUint32(40, dataSize, true);

            // Combine header and data
            const wavBlob = new Blob([header, combined], { type: 'audio/wav' });
            const url = URL.createObjectURL(wavBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lyria_music.wav';
            a.click();
            URL.revokeObjectURL(url);
        };
    </script>
</body>
</html>
